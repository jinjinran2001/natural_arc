{
    "apply_func": "Take a function {arg1} and apply it to the arguments {arg2}, {arg3}, and so on. This means you use {arg1} like a machine that takes in the inputs {arg2}, {arg3}, etc., and gives you an output. For example, if {arg1} is a function that adds numbers, and {arg2} and {arg3} are numbers, this function will add them together.",
    "identity": "This function simply returns whatever you give it as input {arg1}. It does nothing to change it. Think of it like passing something through without any changes. If you give it a number, it gives you back the same number.",
    "add": "Add {arg1} and {arg2} together. If they are numbers, it adds them like regular addition. If they are pairs of numbers (like coordinates), it adds the first numbers together and the second numbers together. For example, adding (2, 3) and (4, 5) gives you (6, 8).",
    "subtract": "Subtract {arg2} from {arg1}. If they are numbers, it subtracts them like usual. If they are pairs of numbers, it subtracts the first numbers and the second numbers separately. For example, subtracting (5, 7) minus (2, 3) gives you (3, 4).",
    "multiply": "Multiply {arg1} by {arg2}. If they are numbers, it multiplies them normally. If they are pairs of numbers, it multiplies the first numbers together and the second numbers together. For example, multiplying (2, 3) by (4, 5) gives you (8, 15).",
    "divide": "Divide {arg1} by {arg2} using whole number division (no fractions). If they are numbers, it divides them and only keeps the whole number part. If they are pairs, it divides the first numbers and the second numbers separately. For example, dividing (9, 8) by (2, 2) gives you (4, 4).",
    "invert": "Turn {arg1} into its opposite with respect to addition. If {arg1} is a number, it changes its sign (positive becomes negative and vice versa). For example, if {arg1} is 5, it becomes -5. If it is a pair of numbers, it changes the sign of both numbers.",
    "even": "Check if the number {arg1} is even. An even number is divisible by 2 without any leftovers. If {arg1} is even, it returns True; otherwise, it returns False.",
    "double": "Multiply {arg1} by 2. If {arg1} is a number, it becomes twice as big. If {arg1} is a pair of numbers, both numbers are doubled. For example, doubling (3, 4) gives you (6, 8).",
    "halve": "Divide {arg1} by 2, keeping only the whole number part. If {arg1} is a number, it becomes half as big (without fractions). If {arg1} is a pair, both numbers are halved this way. For example, halving (5, 7) gives you (2, 3).",
    "flip": "Change the truth value of {arg1}. If {arg1} is True, it becomes False. If it is False, it becomes True. It\u2019s like switching a light on and off.",
    "equality": "Check if {arg1} and {arg2} are the same. If they are equal, it returns True; if not, it returns False. For example, if both are the number 5, it returns True.",
    "contained": "Check if {arg1} is inside {arg2}. If {arg1} is an element in the container {arg2}, it returns True. For example, checking if 3 is in the list [1, 2, 3] returns True.",
    "combine": "Join {arg1} and {arg2} together into one container. If they are lists or tuples, it puts them one after the other. For example, combining [1, 2] and [3, 4] gives you [1, 2, 3, 4].",
    "intersection": "Find the common elements between {arg1} and {arg2}. This function returns a set of items that are in both {arg1} and {arg2}. For example, the intersection of {1, 2, 3} and {2, 3, 4} is {2, 3}.",
    "difference": "Find elements that are in {arg1} but not in {arg2}. This function returns a set of these unique items. For example, the difference between {1, 2, 3} and {2, 3, 4} is {1}.",
    "dedupe": "Remove duplicate items from {arg1}. This function returns a tuple with only unique elements, keeping the original order. For example, deduping (1, 2, 2, 3) gives you (1, 2, 3).",
    "order": "Sort the elements in {arg1} using a custom function {arg2}. This means arranging the items in a specific order defined by {arg2}. For example, you might sort numbers from smallest to largest.",
    "repeat": "Create a tuple that contains {arg1} repeated {arg2} times. For example, if {arg1} is 5 and {arg2} is 3, it returns (5, 5, 5).",
    "greater": "Check if {arg1} is larger than {arg2}. If it is, the function returns True; otherwise, it returns False.",
    "size": "Find out how many elements are in {arg1}. This function counts the number of items. For example, the size of [1, 2, 3] is 3.",
    "merge": "Combine all the containers inside {arg1} into one big container. If {arg1} is a list of lists, it flattens them into a single list with all the elements.",
    "maximum": "Find the largest number in {arg1}. If {arg1} is empty, it returns 0. For example, the maximum of [1, 5, 3] is 5.",
    "minimum": "Find the smallest number in {arg1}. If {arg1} is empty, it returns 0. For example, the minimum of [1, 5, 3] is 1.",
    "valmax": "Find the element in {arg1} that gives the biggest value when {arg2} is applied to it, and return that value. For example, if {arg2} squares numbers, and {arg1} is [1, 2, 3], it finds that 3 gives the largest square (9).",
    "valmin": "Find the element in {arg1} that gives the smallest value when {arg2} is applied to it, and return that value. Similar to valmax, but looks for the smallest result.",
    "argmax": "Find the element in {arg1} that makes {arg2} give the largest result. It returns that element from {arg1}. For example, if {arg2} is \"length\", and {arg1} is [\"apple\", \"banana\"], it returns \"banana\" because it is longer.",
    "argmin": "Find the element in {arg1} that makes {arg2} give the smallest result. It returns that element from {arg1}.",
    "mostcommon": "Find the element that appears most often in {arg1}. For example, in [1, 2, 2, 3], the most common element is 2.",
    "leastcommon": "Find the element that appears least often in {arg1}. For example, in [1, 1, 2, 3, 3], the least common elements are 2 (since it appears only once).",
    "initset": "Create a set that contains only {arg1}. This is like making a collection with a single item.",
    "both": "Check if both {arg1} and {arg2} are True. It returns True only if both are True. For example, if {arg1} is True and {arg2} is False, it returns False.",
    "either": "Check if at least one of {arg1} or {arg2} is True. It returns True if one or both are True.",
    "increment": "Add one to {arg1}. If {arg1} is a number, it becomes one larger. If it is a pair, both numbers increase by one.",
    "decrement": "Subtract one from {arg1}. If {arg1} is a number, it becomes one smaller. If it is a pair, both numbers decrease by one.",
    "crement": "If {arg1} is positive, increase it by one. If it is negative, decrease it by one. If it is zero, it stays the same. This moves {arg1} one step closer to zero.",
    "sign": "Find out if {arg1} is positive, negative, or zero. If positive, it returns 1; if negative, -1; if zero, 0. This tells you the \"direction\" of {arg1}.",
    "positive": "Check if {arg1} is greater than zero. If it is, returns True; otherwise, returns False.",
    "toivec": "Create a vertical movement vector of length {arg1}. It returns a pair where the first number is {arg1} (up or down movement) and the second is 0 (no sideways movement).",
    "tojvec": "Create a horizontal movement vector of length {arg1}. It returns a pair where the first number is 0 (no up or down movement) and the second is {arg1} (left or right movement).",
    "sfilter": "Go through each element in {arg1} and keep only those that satisfy the condition {arg2}. This means if {arg2} returns True for an element, it is kept; otherwise, it is discarded.",
    "mfilter": "Filter the elements in {arg1} using {arg2}, and then merge the results into one set. This combines filtering and merging in one step.",
    "extract": "Find and return the first element in {arg1} that satisfies the condition {arg2}. It stops searching after finding the first match.",
    "totuple": "Convert {arg1} into a tuple. This means putting all the elements of {arg1} into a tuple structure.",
    "first": "Get the first element from {arg1}. This is the element at the very beginning.",
    "last": "Get the last element from {arg1}. This is the element at the very end.",
    "insert": "Add {arg1} into the set {arg2}. It returns a new set that includes {arg1} and everything in {arg2}.",
    "remove": "Take out {arg1} from {arg2}. It returns a container with all the elements of {arg2} except {arg1}.",
    "other": "From {arg1}, get an element that is not {arg2}. It finds another item different from {arg2}.",
    "interval": "Create a sequence of numbers starting from {arg1}, going up to but not including {arg2}, counting by {arg3}. For example, interval(0, 5, 1) gives (0, 1, 2, 3, 4).",
    "astuple": "Make a tuple from {arg1} and {arg2}. It returns ({arg1}, {arg2}).",
    "product": "Find all possible pairs where the first element is from {arg1} and the second is from {arg2}. This is called the Cartesian product.",
    "pair": "Combine {arg1} and {arg2} into pairs by matching up their elements in order. It returns a tuple of these pairs.",
    "branch": "If {arg1} is True, return {arg2}; otherwise, return {arg3}. It\u2019s like choosing between two options based on a condition.",
    "compose": "Create a new function that first applies {arg2} to an input and then applies {arg1} to the result. It\u2019s like chaining two functions together.",
    "chain": "Create a new function that applies three functions in order: first {arg3}, then {arg2}, then {arg1}. It\u2019s like linking three machines in a row.",
    "matcher": "Make a function that checks if applying {arg1} to an input equals {arg2}. It returns True if it matches, False otherwise.",
    "rbind": "Create a new function from {arg1} where the last argument is fixed as {arg2}. It means you don\u2019t need to provide that last argument anymore when using the new function.",
    "lbind": "Create a new function from {arg1} where the first argument is fixed as {arg2}. Now, you only need to provide the remaining arguments.",
    "power": "Apply the function {arg1} to an input {arg2} times in a row. For example, if {arg1} doubles a number and you apply it 3 times, it\u2019s like doubling three times.",
    "fork": "Create a new function that takes an input, applies {arg2} and {arg3} to it separately, and then applies {arg1} to both results. It combines the outcomes of two functions using another function.",
    "apply": "Apply the function {arg1} to each element in {arg2}. It returns a container with all the results. For example, if {arg1} doubles numbers and {arg2} is [1, 2, 3], it returns [2, 4, 6].",
    "rapply": "Apply each function in {arg1} to the value {arg2}. It returns a container with the results from each function.",
    "mapply": "Apply the function {arg1} to each element in {arg2}, and then merge all the results into one set.",
    "papply": "Apply the function {arg1} to pairs of elements from {arg2} and {arg3} that are at the same position. It returns a tuple of the results.",
    "mpapply": "Apply the function {arg1} to all pairs of elements from {arg2} and {arg3}, and merge the results into one set.",
    "prapply": "Apply the function {arg1} to every possible pair from the product of {arg2} and {arg3}. It\u2019s like applying {arg1} to all combinations of elements from both containers.",
    "mostcolor": "Find the color that appears most often in {arg1}. If {arg1} is a grid or a set of elements with colors, it tells you which color is the most common.",
    "leastcolor": "Find the color that appears least often in {arg1}. This is the color with the fewest occurrences.",
    "height": "Find out how tall {arg1} is. If {arg1} is a grid, it tells you the number of rows. If it\u2019s an object, it calculates the vertical size based on its positions.",
    "width": "Find out how wide {arg1} is. If {arg1} is a grid, it tells you the number of columns. If it\u2019s an object, it calculates the horizontal size.",
    "shape": "Get both the height and width of {arg1}. It returns a pair like (height, width).",
    "portrait": "Check if {arg1} is taller than it is wide. If the height is greater than the width, it returns True.",
    "colorcount": "Count how many times the color {arg2} appears in {arg1}. It goes through {arg1} and adds up all the cells with that color.",
    "colorfilter": "From {arg1}, select only the objects that have the color {arg2}. It returns a set of these objects.",
    "sizefilter": "From {arg1}, select only the elements that have a size of {arg2}. It filters items based on their length or number of elements.",
    "asindices": "Get all the positions (like coordinates) in {arg1}. If {arg1} is a grid, it returns all the (row, column) pairs.",
    "ofcolor": "Find all the positions in {arg1} where the color is {arg2}. It returns the indices of these cells.",
    "ulcorner": "Get the position of the upper-left corner of {arg1}. This is where it starts at the top and leftmost side.",
    "urcorner": "Get the position of the upper-right corner of {arg1}. This is at the top and rightmost side.",
    "llcorner": "Get the position of the lower-left corner of {arg1}. This is at the bottom and leftmost side.",
    "lrcorner": "Get the position of the lower-right corner of {arg1}. This is at the bottom and rightmost side.",
    "crop": "Cut out a part of {arg1} starting at position {arg2} and of size {arg3}. It\u2019s like taking a small piece from a big picture.",
    "toindices": "Get all the positions of the cells in {arg1}. If {arg1} is an object or patch, it returns all the (row, column) pairs where it has cells.",
    "recolor": "Change the color of {arg2} to {arg1}. This makes all parts of {arg2} have the new color.",
    "shift": "Move {arg1} by {arg2} positions. The first number in {arg2} is how much to move up or down; the second is how much to move left or right.",
    "normalize": "Move {arg1} so that its upper-left corner is at position (0, 0). It shifts the object to the origin.",
    "dneighbors": "Find the direct neighbors of position {arg1}. These are the cells directly above, below, to the left, and to the right of {arg1}.",
    "ineighbors": "Find the diagonal neighbors of position {arg1}. These are the cells at the corners around {arg1}.",
    "neighbors": "Find all neighboring positions of {arg1}, including direct and diagonal neighbors.",
    "objects": "Find all the objects in {arg1} based on the settings: univalued={arg2} (objects of one color), diagonal connectivity={arg3}, and excluding background={arg4}. It groups cells into objects accordingly.",
    "partition": "Split {arg1} into groups where each group has cells of the same color. It returns a set of these color-based objects.",
    "fgpartition": "Like partition, but excludes the background color (the most common color). It only considers foreground colors.",
    "uppermost": "Find the smallest row index in {arg1}. This tells you how far up {arg1} goes.",
    "lowermost": "Find the largest row index in {arg1}. This tells you how far down {arg1} goes.",
    "leftmost": "Find the smallest column index in {arg1}. This tells you how far left {arg1} goes.",
    "rightmost": "Find the largest column index in {arg1}. This tells you how far right {arg1} goes.",
    "square": "Check if {arg1} forms a perfect square. That means its height and width are the same.",
    "vline": "Check if {arg1} is a vertical line. This means it has a width of 1 and can be many cells tall.",
    "hline": "Check if {arg1} is a horizontal line. This means it has a height of 1 and can be many cells wide.",
    "hmatching": "Check if {arg1} and {arg2} have any rows in common. That is, they have cells on the same horizontal lines.",
    "vmatching": "Check if {arg1} and {arg2} have any columns in common. They have cells on the same vertical lines.",
    "manhattan": "Calculate the smallest number of steps it takes to go from {arg1} to {arg2}, moving up, down, left, or right. It finds the closest distance between any cells of {arg1} and {arg2}.",
    "adjacent": "Check if {arg1} and {arg2} are next to each other, touching at any edge or corner.",
    "bordering": "Check if {arg1} touches the edge of {arg2}. For example, if {arg1} is at the very top row of {arg2}, it is bordering.",
    "centerofmass": "Find the average position of all the cells in {arg1}. It\u2019s like finding the balancing point.",
    "palette": "Get all the different colors used in {arg1}. It returns a set of these colors.",
    "numcolors": "Count how many different colors are used in {arg1}.",
    "color": "Get the color of {arg1}. If {arg1} has only one color, it returns that color.",
    "toobject": "Create an object from {arg1} using the colors from {arg2}. It maps the positions in {arg1} to their corresponding colors in {arg2}.",
    "asobject": "Convert {arg1} into an object where each cell has its color and position. It represents the grid as a collection of colored cells.",
    "rot90": "Rotate {arg1} by 90 degrees clockwise. It turns the grid or object a quarter turn to the right.",
    "rot180": "Rotate {arg1} by 180 degrees. It turns the grid or object upside down.",
    "rot270": "Rotate {arg1} by 270 degrees clockwise (which is the same as 90 degrees counterclockwise).",
    "hmirror": "Flip {arg1} over its horizontal axis. It\u2019s like turning it upside down.",
    "vmirror": "Flip {arg1} over its vertical axis. It\u2019s like flipping it left to right.",
    "dmirror": "Reflect {arg1} over its main diagonal (from top-left to bottom-right). It swaps rows and columns.",
    "cmirror": "Reflect {arg1} over the counter-diagonal (from bottom-left to top-right).",
    "fill": "In {arg1}, change the color of the positions in {arg3} to {arg2}. It paints these specific cells.",
    "paint": "Place the object {arg2} onto the grid {arg1}. It overlays {arg2} onto {arg1} at the corresponding positions.",
    "underfill": "In {arg1}, fill the positions in {arg3} with {arg2}, but only if they are currently the background color. It doesn\u2019t overwrite any non-background cells.",
    "underpaint": "Paint {arg2} onto {arg1}, but only where {arg1} has the background color. It adds {arg2} without covering existing content.",
    "hupscale": "Make {arg1} wider by repeating each column {arg2} times. It stretches the grid horizontally.",
    "vupscale": "Make {arg1} taller by repeating each row {arg2} times. It stretches the grid vertically.",
    "upscale": "Increase the size of {arg1} by a factor of {arg2} in both height and width. It makes each cell into a block of {arg2}\u00d7{arg2} cells.",
    "downscale": "Reduce the size of {arg1} by taking every {arg2}th cell in both directions. It shrinks the grid.",
    "hconcat": "Join {arg2} to the right side of {arg1}, creating a wider grid.",
    "vconcat": "Place {arg2} below {arg1}, creating a taller grid.",
    "subgrid": "Extract the smallest grid from {arg2} that contains all of {arg1}. It crops {arg2} around {arg1}.",
    "hsplit": "Divide {arg1} into {arg2} equal parts horizontally. It splits the grid into vertical slices.",
    "vsplit": "Divide {arg1} into {arg2} equal parts vertically. It splits the grid into horizontal slices.",
    "cellwise": "Compare each cell in {arg1} and {arg2}. If they are the same, keep the value; if not, use {arg3}. It creates a new grid showing where they match.",
    "replace": "In {arg1}, change all occurrences of {arg2} to {arg3}. It swaps one color for another.",
    "switch": "In {arg1}, swap the colors {arg2} and {arg3}. All {arg2}s become {arg3}s and vice versa.",
    "center": "Find the central position of {arg1}. This is usually the middle point of its bounding box.",
    "position": "Find the direction from {arg1} to {arg2}. It returns a vector indicating where {arg2} is relative to {arg1}.",
    "index": "Get the color or value at position {arg2} in {arg1}. It tells you what is at that spot.",
    "canvas": "Create a new grid of size {arg2}, filled entirely with {arg1}. It\u2019s like making a blank drawing area.",
    "corners": "Get the positions of all four corners of {arg1}.",
    "connect": "Draw a straight line between {arg1} and {arg2}. It returns all the positions along that line.",
    "cover": "In {arg1}, replace {arg2} with the background color, effectively removing it from the grid.",
    "trim": "Remove the outermost rows and columns from {arg1}. It makes the grid smaller by cutting off the edges.",
    "move": "In {arg1}, move {arg2} by the offset {arg3}. It shifts {arg2} to a new position on the grid.",
    "tophalf": "Get the upper half of {arg1}. It returns the top part of the grid.",
    "bottomhalf": "Get the lower half of {arg1}. It returns the bottom part of the grid.",
    "lefthalf": "Get the left half of {arg1}. It returns the left side of the grid.",
    "righthalf": "Get the right half of {arg1}. It returns the right side of the grid.",
    "vfrontier": "Get a vertical line at column {arg1[1]}. It\u2019s a set of positions forming a straight vertical line.",
    "hfrontier": "Get a horizontal line at row {arg1[0]}. It\u2019s a set of positions forming a straight horizontal line.",
    "backdrop": "Get all the positions inside the rectangle that encloses {arg1}. It includes all cells within its bounding box.",
    "delta": "Get the positions within {arg1}\u2019s bounding box that are not part of {arg1}. It\u2019s the background area surrounding {arg1} inside its box.",
    "gravitate": "Find out how {arg1} should move to touch {arg2}. It calculates the minimal shift needed to make them adjacent.",
    "inbox": "Get the inner border just inside {arg1}\u2019s edges. It\u2019s like a frame one cell inside.",
    "outbox": "Get the outer border just outside {arg1}\u2019s edges. It\u2019s like a frame one cell outside.",
    "box": "Get the outline of {arg1}, showing its edges. It includes all positions along its border.",
    "shoot": "From starting point {arg1}, create a line extending in direction {arg2}. It continues infinitely (up to a limit).",
    "occurrences": "Find all the places where {arg2} appears in {arg1}. It returns the starting positions of each occurrence.",
    "frontiers": "Find all the rows or columns in {arg1} that are filled with the same color. It identifies uniform lines.",
    "compress": "Remove any uniform rows or columns (frontiers) from {arg1}. It shrinks the grid by eliminating these edges.",
    "hperiod": "Find how often {arg1} repeats horizontally. It returns the smallest number of columns after which the pattern repeats.",
    "vperiod": "Find how often {arg1} repeats vertically. It returns the smallest number of rows after which the pattern repeats."
}